#!/usr/bin/perl
#
# 15bpp-2-bmp.pl
# Convert SEGA Saturn 15bpp graphic format to bitmap.
#
# Version 1.0
#
# Written by Derek Pascarella (ateam)

# Include necessary modules.
use strict;

# Store input parameters.
my $infile = $ARGV[0];
my $width = $ARGV[1];
my $height = $ARGV[2];

# Ensure proper input parameters.
if($infile eq "" || $width eq "" || $height eq "")
{
	die "\n15bpp-2-bmp v1.0\nConvert SEGA Saturn 15bpp graphic format to bitmap.\n\nWritten by Derek Pascarella (ateam)\n\nOne or more input parameters missing...\n\nUsage:\n15bpp-2-bmp <15BPP_FILE> <WIDTH> <HEIGHT>\n\n";
}
elsif(!-e $infile || !-R $infile)
{
	die "\n15bpp-2-bmp v1.0\nConvert SEGA Saturn 15bpp graphic format to bitmap.\n\nWritten by Derek Pascarella (ateam)\n\nCould not find or read $infile...\n\nUsage:\n15bpp-2-bmp <15BPP_FILE> <WIDTH> <HEIGHT>\n\n";
}
elsif($width eq "" || $height eq "" || $width !~ /^[+-]?\d+$/ || $height !~ /^[+-]?\d+$/)
{
	die "\n15bpp-2-bmp v1.0\nConvert SEGA Saturn 15bpp graphic format to bitmap.\n\nWritten by Derek Pascarella (ateam)\n\nWidth and height parameters must be whole numbers...\n\nUsage:\n15bpp-2-bmp <15BPP_FILE> <WIDTH> <HEIGHT>\n\n";
}

# Construct output filename.
my $outfile = $infile . ".BMP";

# Status message.
print "\n15bpp-2-bmp v1.0\n";
print "Convert SEGA Saturn 15bpp graphic format to bitmap.\n\n";
print "Written by Derek Pascarella (ateam)\n\n";
print "Converting $infile to $outfile...\n\n";

# Open input and output files.
open(my $in, '<:raw', $infile) or die "Can't open $infile: $!";
open(my $out, '>:raw', $outfile) or die "Can't open $outfile: $!";

# Construct the BMP header (14 bytes) and DIB header (40 bytes) for 24-bit bitmap image.
my $file_header = "BM" . pack("V", 14 + 40 + $width * $height * 3) . pack("V", 0) . pack("V", 14 + 40);
my $dib_header = pack("V", 40) . pack("V", $width) . pack("V", $height) . pack("v", 1) .
				 pack("v", 24) . pack("V", 0) . pack("V", $width * $height * 3) .
				 pack("V", 0) . pack("V", 0) . pack("V", 0) . pack("V", 0);

# Write header data to file.
print $out $file_header;
print $out $dib_header;

# Read in and convert all pixel data.
my @rows;

for my $y (1..$height)
{
	my $row = '';

	for my $x (1..$width)
	{
		# Read 2 bytes per pixel.
		my $raw_pixel;
		read($in, $raw_pixel, 2);
		
		# Convert from big-endian.
		my $value = unpack("n", $raw_pixel);

		# Check for transparency.
		my $is_transparent = !($value & 0x8000);

		my $r = ($value >> 10) & 0x1F;
		my $g = ($value >> 5) & 0x1F;
		my $b = $value & 0x1F;
		
		if($is_transparent)
		{
			# Set to 255 without bit-shifting for full magenta to represent transparent pixels.
			$r = 255;
			$g = 0;
			$b = 255;
		}
		else
		{
			# Extract and scale RGB values if not transparent.
			$r = ($value >> 10) & 0x1F;
			$g = ($value >> 5) & 0x1F;
			$b = $value & 0x1F;

			# Scale up to 8 bits per channel.
			$r = ($r << 3) | ($r >> 2);
			$g = ($g << 3) | ($g >> 2);
			$b = ($b << 3) | ($b >> 2);
		}

		$row .= pack("CCC", $r, $g, $b);
	}

	# Push data to array.
	push @rows, $row;
}

# Write pixel data in reverse order.
for my $row (reverse @rows)
{
	print $out $row;
}

# Close input and output files.
close($in);
close($out);

# Status message.
print "Complete!\n\n";